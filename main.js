/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KoreanDictionaryPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// api.ts
var import_obsidian = require("obsidian");
function parseXMLResponse(xmlText) {
  var _a, _b, _c, _d, _e;
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlText, "text/xml");
  const errorNode = xmlDoc.querySelector("error");
  if (errorNode) {
    const errorCode = parseInt(errorNode.textContent || "0");
    if (errorCode !== 0) {
      const errorDesc = ((_a = xmlDoc.querySelector("error_description")) == null ? void 0 : _a.textContent) || "Unknown error";
      return {
        channel: { total: 0, num: 0, title: "", start: 0 },
        error: errorCode,
        error_description: errorDesc
      };
    }
  }
  const channel = xmlDoc.querySelector("channel");
  if (!channel) {
    return { channel: { total: 0, num: 0, title: "", start: 0 } };
  }
  const items = [];
  const itemNodes = channel.querySelectorAll("item");
  itemNodes.forEach((itemNode) => {
    var _a2, _b2, _c2, _d2;
    const word = ((_a2 = itemNode.querySelector("word")) == null ? void 0 : _a2.textContent) || "";
    const pos = ((_b2 = itemNode.querySelector("pos")) == null ? void 0 : _b2.textContent) || "";
    const target_code = ((_c2 = itemNode.querySelector("target_code")) == null ? void 0 : _c2.textContent) || "";
    const sup_no = ((_d2 = itemNode.querySelector("sup_no")) == null ? void 0 : _d2.textContent) || "0";
    const senses = [];
    const senseNodes = itemNode.querySelectorAll("sense");
    senseNodes.forEach((senseNode) => {
      var _a3, _b3;
      const sense_no = ((_a3 = senseNode.querySelector("sense_no")) == null ? void 0 : _a3.textContent) || "1";
      const definition = ((_b3 = senseNode.querySelector("definition")) == null ? void 0 : _b3.textContent) || "";
      const examples = [];
      const exampleNodes = senseNode.querySelectorAll("example");
      exampleNodes.forEach((exNode) => {
        const exampleText = exNode.textContent || "";
        if (exampleText.trim()) {
          examples.push({ example: exampleText });
        }
      });
      senses.push({
        sense_no,
        definition,
        example: examples
      });
    });
    items.push({
      word,
      pos,
      target_code,
      sup_no,
      sense: senses
    });
  });
  return {
    channel: {
      total: parseInt(((_b = channel.querySelector("total")) == null ? void 0 : _b.textContent) || "0"),
      num: parseInt(((_c = channel.querySelector("num")) == null ? void 0 : _c.textContent) || "0"),
      title: ((_d = channel.querySelector("title")) == null ? void 0 : _d.textContent) || "",
      start: parseInt(((_e = channel.querySelector("start")) == null ? void 0 : _e.textContent) || "0"),
      item: items
    }
  };
}
async function searchDictionary(word, apiKey) {
  try {
    const encodedWord = encodeURIComponent(word);
    const url = `https://stdict.korean.go.kr/api/search.do?key=${apiKey}&q=${encodedWord}&num=10`;
    const response = await (0, import_obsidian.requestUrl)({
      url,
      method: "GET"
    });
    const data = parseXMLResponse(response.text);
    if (data.error) {
      throw new Error(data.error_description || "API Error");
    }
    if (!data.channel.item || data.channel.item.length === 0) {
      return null;
    }
    const entries = [];
    const posCounter = {};
    data.channel.item.forEach((entry) => {
      const senses = Array.isArray(entry.sense) ? entry.sense : entry.sense ? [entry.sense] : [];
      const pos = entry.pos || "\uD488\uC0AC \uBBF8\uC0C1";
      if (senses.length > 0) {
        senses.forEach((sense) => {
          if (!posCounter[pos]) {
            posCounter[pos] = 0;
          }
          posCounter[pos]++;
          entries.push({
            pos,
            senseNum: posCounter[pos].toString(),
            definition: sense.definition || ""
          });
        });
      } else {
        if (!posCounter[pos]) {
          posCounter[pos] = 0;
        }
        posCounter[pos]++;
        entries.push({
          pos,
          senseNum: posCounter[pos].toString(),
          definition: entry.word || ""
        });
      }
    });
    return {
      word,
      entries
    };
  } catch (error) {
    new import_obsidian.Notice("\uC0AC\uC804 \uAC80\uC0C9 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
    return null;
  }
}
async function queryOpenAI(prompt, apiKey, model) {
  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model,
      messages: [
        {
          role: "system",
          content: "\uB2F9\uC2E0\uC740 \uD55C\uAD6D\uC5B4 \uC5B8\uC5B4 \uC804\uBB38\uAC00\uC785\uB2C8\uB2E4. \uC8FC\uC5B4\uC9C4 \uB2E8\uC5B4\uC758 \uD55C\uC790, \uC720\uC758\uC5B4, \uBC18\uC758\uC5B4, \uC6A9\uB840\uB97C JSON \uD615\uC2DD\uC73C\uB85C \uC81C\uACF5\uD569\uB2C8\uB2E4."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 1500
    })
  });
  const data = await response.json();
  if (data.error) {
    const errorMsg = data.error.message || "";
    if (errorMsg.includes("rate_limit") || errorMsg.includes("too many requests")) {
      throw new Error("RATE_LIMIT");
    }
    if (errorMsg.includes("quota") || errorMsg.includes("insufficient_quota")) {
      throw new Error("QUOTA_EXCEEDED");
    }
    throw new Error(errorMsg);
  }
  return data.choices[0].message.content;
}
async function queryGemini(prompt, apiKey, model) {
  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 1500
      }
    })
  });
  const data = await response.json();
  if (data.error) {
    const errorMsg = data.error.message || JSON.stringify(data.error);
    if (errorMsg.includes("RESOURCE_EXHAUSTED") || response.status === 429) {
      throw new Error("RATE_LIMIT");
    }
    if (errorMsg.includes("quota")) {
      throw new Error("QUOTA_EXCEEDED");
    }
    throw new Error(errorMsg);
  }
  if (!data.candidates || data.candidates.length === 0) {
    throw new Error("Gemini API \uC751\uB2F5 \uC624\uB958");
  }
  if (!data.candidates[0].content || !data.candidates[0].content.parts || data.candidates[0].content.parts.length === 0) {
    throw new Error("Gemini API \uC751\uB2F5 \uD615\uC2DD \uC624\uB958");
  }
  return data.candidates[0].content.parts[0].text;
}
async function queryGroq(prompt, apiKey, model) {
  const response = await fetch("https://api.groq.com/openai/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model,
      messages: [
        {
          role: "system",
          content: "\uB2F9\uC2E0\uC740 \uD55C\uAD6D\uC5B4 \uC5B8\uC5B4 \uC804\uBB38\uAC00\uC785\uB2C8\uB2E4. \uC8FC\uC5B4\uC9C4 \uB2E8\uC5B4\uC758 \uD55C\uC790, \uC720\uC758\uC5B4, \uBC18\uC758\uC5B4, \uC6A9\uB840\uB97C JSON \uD615\uC2DD\uC73C\uB85C \uC81C\uACF5\uD569\uB2C8\uB2E4."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 1500
    })
  });
  const data = await response.json();
  if (data.error) {
    const errorMsg = data.error.message || "";
    if (errorMsg.includes("rate_limit") || errorMsg.includes("too many requests") || response.status === 429) {
      throw new Error("RATE_LIMIT");
    }
    if (errorMsg.includes("quota")) {
      throw new Error("QUOTA_EXCEEDED");
    }
    throw new Error(errorMsg);
  }
  return data.choices[0].message.content;
}
async function generateAIContent(word, definition, provider, apiKey, model, generateFields) {
  try {
    if (generateFields && !generateFields.hanja && !generateFields.synonyms && !generateFields.antonyms && !generateFields.examples) {
      return {};
    }
    const prompt = `\uB2E8\uC5B4: ${word}
\uC815\uC758: ${definition}

**\uC911\uC694**: \uC704 '\uC815\uC758'\uC5D0 \uC815\uD655\uD788 \uBD80\uD569\uD558\uB294 \uC758\uBBF8\uB85C\uB9CC \uB2F5\uBCC0\uD558\uC138\uC694. \uAC19\uC740 \uBC1C\uC74C\uC774\uB77C\uB3C4 \uB2E4\uB978 \uC758\uBBF8(\uB3D9\uC74C\uC774\uC758\uC5B4)\uB294 \uC808\uB300 \uD63C\uB3D9\uD558\uC9C0 \uB9C8\uC138\uC694.

\uB2E4\uC74C JSON \uD615\uC2DD\uC73C\uB85C\uB9CC \uC751\uB2F5\uD558\uC138\uC694:
{
  "hanja": "'${word}' \uB2E8\uC5B4\uAC00 \uD55C\uC790\uC5B4\uC778 \uACBD\uC6B0\uC5D0\uB9CC \uD574\uB2F9 \uD55C\uC790 \uD45C\uAE30. \uACE0\uC720\uC5B4(\uC0AC\uB791, \uD558\uB298 \uB4F1)\uB098 \uC678\uB798\uC5B4(\uCEF4\uD4E8\uD130 \uB4F1)\uB294 \uBE48 \uBB38\uC790\uC5F4. \uD55C\uC790\uC5B4\uB9CC \uD45C\uAE30 (\uC608: \uC560\uC815\u2192\u611B\u60C5, \uC804\uC7C1\u2192\u6230\u722D). \uBC1C\uC74C\uACFC \uC815\uC758 \uBAA8\uB450 \uC815\uD655\uD788 \uBD80\uD569\uD574\uC57C \uD568.",
  "synonyms": ["\uC704 \uC815\uC758\uC758 \uC720\uC758\uC5B4 \uCD5C\uB300 5\uAC1C, \uD55C\uC790\uC5B4\uB294 \uD55C\uC790 \uBCD1\uAE30 (\uC608: \uC804\uC7C1(\u6230\u722D))"],
  "antonyms": ["\uC704 \uC815\uC758\uC758 \uBC18\uC758\uC5B4 \uCD5C\uB300 5\uAC1C, \uD55C\uC790\uC5B4\uB294 \uD55C\uC790 \uBCD1\uAE30"],
  "examples": ["'${word}'\uAC00 \uC704 \uC815\uC758\uC758 \uC758\uBBF8\uB85C \uC2E4\uC81C \uC0AC\uC6A9\uB41C \uBB38\uC7A5. \uC778\uD130\uB137 \uB274\uC2A4/\uC6F9\uD398\uC774\uC9C0 \uB4F1\uC5D0\uC11C \uC2E4\uC81C \uC4F0\uC778 \uC6A9\uB840\uB97C \uCC3E\uB418, \uBC18\uB4DC\uC2DC \uBB38\uB9E5\uC0C1 \uC704 \uC815\uC758\uC5D0 \uBD80\uD569\uD558\uB294 \uC758\uBBF8\uB85C \uC0AC\uC6A9\uB41C \uAC83\uB9CC \uD3EC\uD568. \uC801\uD569\uD55C \uC6A9\uB840\uAC00 \uC5C6\uC73C\uBA74 \uBE48 \uBC30\uC5F4 \uBC18\uD658"]
}

\uC8FC\uC758\uC0AC\uD56D:
- \uC21C\uC218 JSON\uB9CC \uBC18\uD658 (\uCF54\uB4DC\uBE14\uB85D \uC5C6\uC774)
- \uD55C\uC790\uB294 \uD55C\uC790\uC5B4\uB9CC \uD45C\uAE30 (\uACE0\uC720\uC5B4/\uC678\uB798\uC5B4\uB294 \uBE48 \uBB38\uC790\uC5F4)
- \uC608\uBB38\uC740 \uBC18\uB4DC\uC2DC \uBB38\uB9E5\uC0C1 \uC704 \uC815\uC758\uC5D0 \uBD80\uD569\uD574\uC57C \uD568
- \uB3D9\uC74C\uC774\uC758\uC5B4 \uC808\uB300 \uD63C\uB3D9 \uAE08\uC9C0 (\uC608: '\uB208(\u96EA)'\uACFC '\uB208(\u76EE)'\uC740 \uC644\uC804\uD788 \uB2E4\uB984)
- \uAC1C\uC218\uB97C \uC5B5\uC9C0\uB85C \uCC44\uC6B8 \uD544\uC694 \uC5C6\uC74C`;
    let responseText;
    switch (provider) {
      case "chatgpt":
        responseText = await queryOpenAI(prompt, apiKey, model);
        break;
      case "gemini":
        responseText = await queryGemini(prompt, apiKey, model);
        break;
      case "groq":
        responseText = await queryGroq(prompt, apiKey, model);
        break;
      default:
        throw new Error("Unsupported AI provider");
    }
    let jsonText = responseText.trim();
    if (jsonText.startsWith("```")) {
      jsonText = jsonText.replace(/```json?\n?/g, "").replace(/```\n?/g, "").trim();
    }
    return JSON.parse(jsonText);
  } catch (error) {
    const providerNames = {
      "chatgpt": "ChatGPT",
      "gemini": "Gemini",
      "groq": "Groq"
    };
    const errorMsg = error.message || "";
    if (errorMsg === "RATE_LIMIT") {
      return { error: `${providerNames[provider]} API \uC81C\uD55C \uCD08\uACFC (1\uBD84 \uD6C4 \uC7AC\uC2DC\uB3C4)` };
    }
    if (errorMsg === "QUOTA_EXCEEDED") {
      return { error: `${providerNames[provider]} \uC77C\uC77C \uD560\uB2F9\uB7C9 \uC18C\uC9C4 (\uB0B4\uC77C \uC7AC\uC2DC\uB3C4)` };
    }
    return { error: `${providerNames[provider]} API \uC624\uB958` };
  }
}
async function validateDictionaryAPIKey(apiKey) {
  var _a;
  try {
    const url = `https://stdict.korean.go.kr/api/search.do?key=${apiKey}&q=\uC0AC\uB791&num=10`;
    const response = await (0, import_obsidian.requestUrl)({ url, method: "GET" });
    if (response.status !== 200 || !((_a = response.text) == null ? void 0 : _a.trim())) {
      return false;
    }
    const data = parseXMLResponse(response.text);
    if (data.error && data.error !== 0) {
      return false;
    }
    return !!data.channel;
  } catch (error) {
    return false;
  }
}
async function validateAIAPIKey(provider, apiKey, model) {
  try {
    const testPrompt = "\uC548\uB155\uD558\uC138\uC694";
    switch (provider) {
      case "chatgpt":
        await queryOpenAI(testPrompt, apiKey, model);
        break;
      case "gemini":
        await queryGemini(testPrompt, apiKey, model);
        break;
      case "groq":
        await queryGroq(testPrompt, apiKey, model);
        break;
    }
    return true;
  } catch (error) {
    return false;
  }
}

// main.ts
var DEFAULT_SETTINGS = {
  dictionaryApiKey: "",
  dictionaryApiStatus: "none",
  aiProvider: "groq",
  aiApiKey: "",
  aiModel: "llama-3.3-70b-versatile",
  aiApiStatus: "none",
  displayFields: {
    pos: true,
    definition: true,
    hanja: true,
    synonyms: true,
    antonyms: true,
    examples: true
  },
  aiGenerateFields: {
    hanja: true,
    synonyms: true,
    antonyms: true,
    examples: true
  },
  aiEnabled: true
};
var AI_MODELS = {
  chatgpt: ["gpt-4o", "gpt-4o-mini", "gpt-4-turbo"],
  gemini: ["gemini-2.5-flash", "gemini-2.5-flash-lite", "gemini-2.5-pro"],
  groq: ["llama-3.3-70b-versatile", "deepseek-r1-distill-llama-70b", "llama-3.1-70b-versatile"]
};
var VIEW_TYPE_DICTIONARY = "korean-dictionary-view";
var KoreanDictionaryPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerIcons();
    this.registerView(
      VIEW_TYPE_DICTIONARY,
      (leaf) => new DictionaryView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Korean Dictionary", () => {
      this.activateSidebarView();
    });
    this.addCommand({
      id: "open-sidebar-dictionary",
      name: "Open dictionary in sidebar",
      callback: () => {
        this.activateSidebarView();
      }
    });
    this.addCommand({
      id: "open-floating-dictionary",
      name: "Open dictionary in modal",
      callback: () => {
        this.openFloatingModal();
      }
    });
    this.addCommand({
      id: "search-selected-text",
      name: "Search selected text in dictionary",
      editorCallback: (editor, view) => {
        const selectedText = editor.getSelection().trim();
        if (!selectedText) {
          new import_obsidian2.Notice("\uAC80\uC0C9\uD560 \uB2E8\uC5B4\uB97C \uC120\uD0DD\uD574\uC8FC\uC138\uC694");
          return;
        }
        const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_DICTIONARY);
        if (leaves.length > 0) {
          const dictionaryView = leaves[0].view;
          dictionaryView.setSearchWord(selectedText);
        } else {
          this.activateSidebarView().then(() => {
            const leaves2 = this.app.workspace.getLeavesOfType(VIEW_TYPE_DICTIONARY);
            if (leaves2.length > 0) {
              const dictionaryView = leaves2[0].view;
              dictionaryView.setSearchWord(selectedText);
            }
          });
        }
      }
    });
    if (this.settings.dictionaryApiKey && this.settings.dictionaryApiKey.trim().length > 0) {
      this.validateDictionaryAPI(this.settings.dictionaryApiKey).then((isValid) => {
        this.settings.dictionaryApiStatus = isValid ? "success" : "error";
        this.saveSettings();
      });
    }
    this.addSettingTab(new KoreanDictionarySettingTab(this.app, this));
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_DICTIONARY);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (this.settings.dictionaryApiKey && this.settings.dictionaryApiKey.trim().length > 0) {
      this.settings.dictionaryApiStatus = "none";
      await this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // 아이콘 등록
  registerIcons() {
  }
  // 사이드바 뷰 활성화
  async activateSidebarView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_DICTIONARY);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_DICTIONARY,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  // Floating 모달 열기
  openFloatingModal() {
    new DictionaryModal(this.app, this).open();
  }
  // 단어 검색
  async searchWord(word) {
    await this.activateSidebarView();
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_DICTIONARY);
    if (leaves.length > 0) {
      const view = leaves[0].view;
      view.setSearchWord(word);
    }
  }
  // API 검증 (api.ts의 함수 사용)
  async validateDictionaryAPI(apiKey) {
    return await validateDictionaryAPIKey(apiKey);
  }
  async validateAIAPI(provider, apiKey, model) {
    return await validateAIAPIKey(provider, apiKey, model);
  }
};
var DictionaryView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.filterDropdown = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_DICTIONARY;
  }
  getDisplayText() {
    return "Korean Dictionary";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("dict-container");
    const header = container.createDiv({ cls: "dict-header" });
    const searchContainer = header.createDiv({ cls: "dict-search-container" });
    const inputWrapper = searchContainer.createDiv({ cls: "dict-search-input-wrapper" });
    const searchIcon = inputWrapper.createDiv({ cls: "dict-search-icon" });
    searchIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>';
    this.searchInput = inputWrapper.createEl("input", {
      cls: "dict-search-input",
      attr: { placeholder: "" }
    });
    const filterButton = searchContainer.createEl("button", { cls: "dict-icon-button dict-filter-button" });
    (0, import_obsidian2.setIcon)(filterButton, "list-checks");
    const filterText = filterButton.createSpan({ cls: "button-text", text: "Filters" });
    const aiFilterButton = searchContainer.createEl("button", { cls: "dict-icon-button dict-ai-filter-button" });
    (0, import_obsidian2.setIcon)(aiFilterButton, "bot");
    const aiFilterText = aiFilterButton.createSpan({ cls: "button-text", text: "AI" });
    const filterDropdown = document.body.createDiv({ cls: "dict-filter-dropdown dict-hidden" });
    filterDropdown.createDiv({ cls: "dict-filter-section-header", text: "DISPLAY FIELDS" });
    const filterItems = [
      { key: "pos", label: "\uD488\uC0AC" },
      { key: "definition", label: "\uC815\uC758" },
      { key: "hanja", label: "\uD55C\uC790" },
      { key: "synonyms", label: "\uC720\uC758\uC5B4" },
      { key: "antonyms", label: "\uBC18\uC758\uC5B4" },
      { key: "examples", label: "\uC6A9\uB840" }
    ];
    const self = this;
    filterItems.forEach((item) => {
      const itemEl = filterDropdown.createDiv({ cls: "dict-filter-item" });
      const checkmark = itemEl.createSpan({ cls: "dict-filter-checkmark" });
      checkmark.innerHTML = "\u2713";
      itemEl.createSpan({ cls: "dict-filter-label", text: item.label });
      const isSelected = self.plugin.settings.displayFields[item.key];
      if (isSelected) {
        itemEl.addClass("dict-filter-item-selected");
      }
      itemEl.addEventListener("click", () => {
        const currentState = self.plugin.settings.displayFields[item.key];
        self.plugin.settings.displayFields[item.key] = !currentState;
        self.plugin.saveSettings();
        itemEl.toggleClass("dict-filter-item-selected", !currentState);
        const word = self.searchInput.value.trim();
        if (word)
          self.searchWord(word);
      });
    });
    if (this.plugin.settings.aiEnabled) {
      aiFilterButton.addClass("dict-ai-button-active");
    }
    filterButton.addEventListener("click", (e) => {
      e.stopPropagation();
      const isHidden = filterDropdown.hasClass("dict-hidden");
      if (isHidden) {
        const buttonRect = filterButton.getBoundingClientRect();
        filterDropdown.style.position = "fixed";
        filterDropdown.style.top = `${buttonRect.bottom + 4}px`;
        filterDropdown.style.visibility = "hidden";
        filterDropdown.removeClass("dict-hidden");
        const dropdownWidth = filterDropdown.offsetWidth;
        const windowWidth = window.innerWidth;
        let leftPos = buttonRect.left;
        if (leftPos + dropdownWidth > windowWidth - 10) {
          leftPos = buttonRect.right - dropdownWidth;
          if (leftPos < 10) {
            leftPos = 10;
          }
        }
        filterDropdown.style.left = `${leftPos}px`;
        filterDropdown.style.visibility = "visible";
      } else {
        filterDropdown.addClass("dict-hidden");
      }
    });
    aiFilterButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.plugin.settings.aiEnabled = !this.plugin.settings.aiEnabled;
      this.plugin.saveSettings();
      aiFilterButton.toggleClass("dict-ai-button-active", this.plugin.settings.aiEnabled);
      const word = this.searchInput.value.trim();
      if (word)
        this.searchWord(word);
    });
    this.registerDomEvent(document, "click", (e) => {
      const target = e.target;
      if (!filterDropdown.contains(target) && !filterButton.contains(target)) {
        filterDropdown.toggleClass("dict-hidden", true);
      }
    });
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const word = this.searchInput.value.trim();
        if (word)
          this.searchWord(word);
      }
    });
    this.searchInput.addEventListener("focus", () => {
      searchIcon.addClass("dict-search-icon-focused");
    });
    this.searchInput.addEventListener("blur", () => {
      searchIcon.removeClass("dict-search-icon-focused");
    });
    const content = container.createDiv({ cls: "dict-content" });
    this.filterDropdown = filterDropdown;
  }
  async onClose() {
    if (this.filterDropdown) {
      this.filterDropdown.remove();
    }
  }
  setSearchWord(word) {
    this.searchInput.value = word;
    this.searchWord(word);
  }
  async searchWord(word) {
    const content = this.containerEl.querySelector(".dict-content");
    if (!content)
      return;
    content.empty();
    if (!this.plugin.settings.dictionaryApiKey) {
      content.createDiv({ cls: "dict-error", text: "\uC0AC\uC804 API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694." });
      return;
    }
    content.createDiv({ cls: "dict-loading", text: "\uAC80\uC0C9 \uC911..." });
    const result = await searchDictionary(word, this.plugin.settings.dictionaryApiKey);
    content.empty();
    if (!result || result.entries.length === 0) {
      content.createDiv({ cls: "dict-not-found", text: `"${word}"\uC5D0 \uB300\uD55C \uAC80\uC0C9 \uACB0\uACFC\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.` });
      return;
    }
    this.renderSearchResult(content, result);
  }
  renderSearchResult(container, result) {
    const resultDiv = container.createDiv({ cls: "dict-result" });
    result.entries.forEach((entry, index) => {
      const entryDiv = resultDiv.createDiv({ cls: "dict-entry" });
      if (this.plugin.settings.displayFields.pos) {
        const posSection = entryDiv.createDiv({ cls: "dict-section" });
        const posLabelCell = posSection.createDiv({ cls: "dict-label-cell" });
        posLabelCell.createSpan({ cls: "dict-label-tag dict-label-pos", text: "\uD488  \uC0AC" });
        const posContent = posSection.createSpan({ cls: "dict-content-text" });
        posContent.innerHTML = `${entry.pos}<sup>${entry.senseNum}</sup>`;
      }
      if (this.plugin.settings.displayFields.definition) {
        const defSection = entryDiv.createDiv({ cls: "dict-section" });
        const defLabelCell = defSection.createDiv({ cls: "dict-label-cell" });
        defLabelCell.createSpan({ cls: "dict-label-tag dict-label-definition", text: "\uC815  \uC758" });
        defSection.createSpan({ cls: "dict-content-text", text: entry.definition });
      }
      if (this.plugin.settings.aiApiKey) {
        this.renderAISection(entryDiv, result.word, entry.definition);
      }
      if (index < result.entries.length - 1) {
        resultDiv.createDiv({ cls: "dict-separator" });
      }
    });
  }
  async renderAISection(container, word, definition) {
    const { displayFields, aiGenerateFields } = this.plugin.settings;
    if (!aiGenerateFields.hanja && !aiGenerateFields.synonyms && !aiGenerateFields.antonyms && !aiGenerateFields.examples) {
      return;
    }
    const sections = {};
    if (displayFields.hanja) {
      const section = container.createDiv({ cls: "dict-section" });
      const labelCell = section.createDiv({ cls: "dict-label-cell" });
      labelCell.createSpan({ cls: "dict-label-tag dict-label-hanja", text: "\uD55C  \uC790" });
      const content = section.createDiv({ cls: "dict-content-text" });
      content.createDiv({ cls: "dict-ai-loading-text", text: "\uB85C\uB529 \uC911..." });
      sections.hanja = { container: section, content };
    }
    if (displayFields.synonyms) {
      const section = container.createDiv({ cls: "dict-section" });
      const labelCell = section.createDiv({ cls: "dict-label-cell" });
      labelCell.createSpan({ cls: "dict-label-tag dict-label-synonym", text: "\uC720\uC758\uC5B4" });
      const content = section.createDiv({ cls: "dict-content-text" });
      content.createDiv({ cls: "dict-ai-loading-text", text: "\uB85C\uB529 \uC911..." });
      sections.synonyms = { container: section, content };
    }
    if (displayFields.antonyms) {
      const section = container.createDiv({ cls: "dict-section" });
      const labelCell = section.createDiv({ cls: "dict-label-cell" });
      labelCell.createSpan({ cls: "dict-label-tag dict-label-antonym", text: "\uBC18\uC758\uC5B4" });
      const content = section.createDiv({ cls: "dict-content-text" });
      content.createDiv({ cls: "dict-ai-loading-text", text: "\uB85C\uB529 \uC911..." });
      sections.antonyms = { container: section, content };
    }
    if (displayFields.examples) {
      const section = container.createDiv({ cls: "dict-section" });
      const labelCell = section.createDiv({ cls: "dict-label-cell" });
      labelCell.createSpan({ cls: "dict-label-tag dict-label-example", text: "\uC6A9  \uB840" });
      const content = section.createDiv({ cls: "dict-content-text" });
      content.createDiv({ cls: "dict-ai-loading-text", text: "\uB85C\uB529 \uC911..." });
      sections.examples = { container: section, content };
    }
    if (this.plugin.settings.aiEnabled) {
      const aiResult = await generateAIContent(
        word,
        definition,
        this.plugin.settings.aiProvider,
        this.plugin.settings.aiApiKey,
        this.plugin.settings.aiModel,
        aiGenerateFields
      );
      if (aiResult.error) {
        Object.values(sections).forEach(({ content }) => {
          content.empty();
          content.createDiv({ text: aiResult.error, cls: "dict-ai-error" });
        });
      } else {
        if (sections.hanja) {
          sections.hanja.content.empty();
          if (aiResult.hanja && aiResult.hanja !== "-" && aiResult.hanja.trim() !== "") {
            const hanjaWrapper = sections.hanja.content.createDiv({ cls: "dict-hanja-wrapper" });
            hanjaWrapper.createSpan({ text: aiResult.hanja });
            const copyButton = hanjaWrapper.createEl("button", {
              cls: "dict-copy-button",
              attr: { "aria-label": "\uB178\uD2B8\uC5D0 \uBD99\uC5EC\uB123\uAE30" }
            });
            (0, import_obsidian2.setIcon)(copyButton, "copy");
            copyButton.addEventListener("click", async () => {
              const leaf = this.app.workspace.getMostRecentLeaf();
              const view = leaf == null ? void 0 : leaf.view;
              if (view instanceof import_obsidian2.MarkdownView && view.editor) {
                view.editor.replaceSelection(aiResult.hanja);
                new import_obsidian2.Notice("\uD55C\uC790\uB97C \uB178\uD2B8\uC5D0 \uBD99\uC5EC\uB123\uC5C8\uC2B5\uB2C8\uB2E4");
              } else {
                await navigator.clipboard.writeText(aiResult.hanja);
                new import_obsidian2.Notice("\uD55C\uC790\uB97C \uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uD588\uC2B5\uB2C8\uB2E4");
              }
            });
          } else {
            sections.hanja.content.createSpan({ text: "-" });
          }
        }
        if (sections.synonyms) {
          sections.synonyms.content.empty();
          if (aiResult.synonyms && aiResult.synonyms.length > 0) {
            const list = sections.synonyms.content.createDiv({ cls: "dict-word-list" });
            aiResult.synonyms.forEach((syn) => {
              list.createSpan({ cls: "dict-word-item", text: syn });
            });
          } else {
            sections.synonyms.content.createSpan({ text: "-" });
          }
        }
        if (sections.antonyms) {
          sections.antonyms.content.empty();
          if (aiResult.antonyms && aiResult.antonyms.length > 0) {
            const list = sections.antonyms.content.createDiv({ cls: "dict-word-list" });
            aiResult.antonyms.forEach((ant) => {
              list.createSpan({ cls: "dict-word-item", text: ant });
            });
          } else {
            sections.antonyms.content.createSpan({ text: "-" });
          }
        }
        if (sections.examples) {
          sections.examples.content.empty();
          if (aiResult.examples && aiResult.examples.length > 0) {
            aiResult.examples.forEach((example, i) => {
              const exDiv = sections.examples.content.createDiv({ cls: "dict-example" });
              exDiv.createSpan({ cls: "dict-example-num", text: `${i + 1}.` });
              exDiv.createSpan({ text: example });
            });
          } else {
            sections.examples.content.createSpan({ text: "-" });
          }
        }
      }
    } else {
      Object.values(sections).forEach(({ content }) => {
        content.empty();
        content.createDiv({ text: "AI \uBE44\uD65C\uC131\uD654\uB428", cls: "dict-ai-empty" });
      });
    }
  }
};
var DictionaryModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, searchWord) {
    super(app);
    this.filterDropdown = null;
    this.closeDropdownHandler = null;
    this.plugin = plugin;
    this.searchWord = searchWord || "";
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    modalEl.addClass("dict-modal");
    contentEl.empty();
    const header = contentEl.createDiv({ cls: "dict-header" });
    const searchContainer = header.createDiv({ cls: "dict-search-container dict-modal-search" });
    const inputWrapper = searchContainer.createDiv({ cls: "dict-search-input-wrapper" });
    const searchIcon = inputWrapper.createDiv({ cls: "dict-search-icon" });
    searchIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>';
    this.searchInput = inputWrapper.createEl("input", {
      cls: "dict-search-input",
      attr: { placeholder: "" }
    });
    if (this.searchWord) {
      this.searchInput.value = this.searchWord;
    }
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const word = this.searchInput.value.trim();
        if (word)
          this.performSearch(word);
      }
    });
    const filterButton = searchContainer.createEl("button", { cls: "dict-icon-button dict-filter-button" });
    (0, import_obsidian2.setIcon)(filterButton, "list-checks");
    const filterText = filterButton.createSpan({ cls: "button-text", text: "Filters" });
    const aiFilterButton = searchContainer.createEl("button", { cls: "dict-icon-button dict-ai-filter-button" });
    (0, import_obsidian2.setIcon)(aiFilterButton, "bot");
    const aiFilterText = aiFilterButton.createSpan({ cls: "button-text", text: "AI" });
    const filterDropdown = document.body.createDiv({ cls: "dict-filter-dropdown dict-hidden" });
    filterDropdown.createDiv({ cls: "dict-filter-section-header", text: "DISPLAY FIELDS" });
    const filterItems = [
      { key: "pos", label: "\uD488\uC0AC" },
      { key: "definition", label: "\uC815\uC758" },
      { key: "hanja", label: "\uD55C\uC790" },
      { key: "synonyms", label: "\uC720\uC758\uC5B4" },
      { key: "antonyms", label: "\uBC18\uC758\uC5B4" },
      { key: "examples", label: "\uC6A9\uB840" }
    ];
    const self = this;
    filterItems.forEach((item) => {
      const itemEl = filterDropdown.createDiv({ cls: "dict-filter-item" });
      const checkmark = itemEl.createSpan({ cls: "dict-filter-checkmark" });
      checkmark.innerHTML = "\u2713";
      itemEl.createSpan({ cls: "dict-filter-label", text: item.label });
      const isSelected = self.plugin.settings.displayFields[item.key];
      if (isSelected) {
        itemEl.addClass("dict-filter-item-selected");
      }
      itemEl.addEventListener("click", () => {
        const currentState = self.plugin.settings.displayFields[item.key];
        self.plugin.settings.displayFields[item.key] = !currentState;
        self.plugin.saveSettings();
        itemEl.toggleClass("dict-filter-item-selected", !currentState);
        const word = self.searchInput.value.trim();
        if (word)
          self.performSearch(word);
      });
    });
    if (this.plugin.settings.aiEnabled) {
      aiFilterButton.addClass("dict-ai-button-active");
    }
    filterButton.addEventListener("click", (e) => {
      e.stopPropagation();
      const isHidden = filterDropdown.hasClass("dict-hidden");
      if (isHidden) {
        const buttonRect = filterButton.getBoundingClientRect();
        filterDropdown.style.position = "fixed";
        filterDropdown.style.top = `${buttonRect.bottom + 4}px`;
        filterDropdown.style.visibility = "hidden";
        filterDropdown.removeClass("dict-hidden");
        const dropdownWidth = filterDropdown.offsetWidth;
        const windowWidth = window.innerWidth;
        let leftPos = buttonRect.left;
        if (leftPos + dropdownWidth > windowWidth - 10) {
          leftPos = buttonRect.right - dropdownWidth;
          if (leftPos < 10) {
            leftPos = 10;
          }
        }
        filterDropdown.style.left = `${leftPos}px`;
        filterDropdown.style.visibility = "visible";
      } else {
        filterDropdown.addClass("dict-hidden");
      }
    });
    aiFilterButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.plugin.settings.aiEnabled = !this.plugin.settings.aiEnabled;
      this.plugin.saveSettings();
      aiFilterButton.toggleClass("dict-ai-button-active", this.plugin.settings.aiEnabled);
      const word = this.searchInput.value.trim();
      if (word)
        this.performSearch(word);
    });
    this.closeDropdownHandler = (e) => {
      const target = e.target;
      if (!filterDropdown.contains(target) && !filterButton.contains(target)) {
        filterDropdown.toggleClass("dict-hidden", true);
      }
    };
    document.addEventListener("click", this.closeDropdownHandler);
    this.searchInput.addEventListener("focus", () => {
      searchIcon.addClass("dict-search-icon-focused");
    });
    this.searchInput.addEventListener("blur", () => {
      searchIcon.removeClass("dict-search-icon-focused");
    });
    const content = contentEl.createDiv({ cls: "dict-content" });
    this.filterDropdown = filterDropdown;
    if (this.searchWord) {
      this.performSearch(this.searchWord);
    }
  }
  async performSearch(word) {
    const content = this.contentEl.querySelector(".dict-content");
    if (!content)
      return;
    content.empty();
    if (!this.plugin.settings.dictionaryApiKey) {
      content.createDiv({ cls: "dict-error", text: "\uC0AC\uC804 API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694." });
      return;
    }
    content.createDiv({ cls: "dict-loading", text: "\uAC80\uC0C9 \uC911..." });
    const result = await searchDictionary(word, this.plugin.settings.dictionaryApiKey);
    content.empty();
    if (!result || result.entries.length === 0) {
      content.createDiv({ cls: "dict-not-found", text: `"${word}"\uC5D0 \uB300\uD55C \uAC80\uC0C9 \uACB0\uACFC\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.` });
      return;
    }
    this.renderSearchResult(content, result);
  }
  renderSearchResult(container, result) {
    const resultDiv = container.createDiv({ cls: "dict-result" });
    result.entries.forEach((entry, index) => {
      const entryDiv = resultDiv.createDiv({ cls: "dict-entry" });
      if (this.plugin.settings.displayFields.pos) {
        const posSection = entryDiv.createDiv({ cls: "dict-section" });
        const posLabelCell = posSection.createDiv({ cls: "dict-label-cell" });
        posLabelCell.createSpan({ cls: "dict-label-tag dict-label-pos", text: "\uD488  \uC0AC" });
        const posContent = posSection.createSpan({ cls: "dict-content-text" });
        posContent.innerHTML = `${entry.pos}<sup>${entry.senseNum}</sup>`;
      }
      if (this.plugin.settings.displayFields.definition) {
        const defSection = entryDiv.createDiv({ cls: "dict-section" });
        const defLabelCell = defSection.createDiv({ cls: "dict-label-cell" });
        defLabelCell.createSpan({ cls: "dict-label-tag dict-label-definition", text: "\uC815  \uC758" });
        defSection.createSpan({ cls: "dict-content-text", text: entry.definition });
      }
      if (this.plugin.settings.aiApiKey) {
        this.renderAISection(entryDiv, result.word, entry.definition);
      }
      if (index < result.entries.length - 1) {
        resultDiv.createDiv({ cls: "dict-separator" });
      }
    });
  }
  async renderAISection(container, word, definition) {
    const { displayFields, aiGenerateFields } = this.plugin.settings;
    if (!aiGenerateFields.hanja && !aiGenerateFields.synonyms && !aiGenerateFields.antonyms && !aiGenerateFields.examples) {
      return;
    }
    const sections = {};
    if (displayFields.hanja) {
      const section = container.createDiv({ cls: "dict-section" });
      const labelCell = section.createDiv({ cls: "dict-label-cell" });
      labelCell.createSpan({ cls: "dict-label-tag dict-label-hanja", text: "\uD55C  \uC790" });
      const content = section.createDiv({ cls: "dict-content-text" });
      content.createDiv({ cls: "dict-ai-loading-text", text: "\uB85C\uB529 \uC911..." });
      sections.hanja = { container: section, content };
    }
    if (displayFields.synonyms) {
      const section = container.createDiv({ cls: "dict-section" });
      const labelCell = section.createDiv({ cls: "dict-label-cell" });
      labelCell.createSpan({ cls: "dict-label-tag dict-label-synonym", text: "\uC720\uC758\uC5B4" });
      const content = section.createDiv({ cls: "dict-content-text" });
      content.createDiv({ cls: "dict-ai-loading-text", text: "\uB85C\uB529 \uC911..." });
      sections.synonyms = { container: section, content };
    }
    if (displayFields.antonyms) {
      const section = container.createDiv({ cls: "dict-section" });
      const labelCell = section.createDiv({ cls: "dict-label-cell" });
      labelCell.createSpan({ cls: "dict-label-tag dict-label-antonym", text: "\uBC18\uC758\uC5B4" });
      const content = section.createDiv({ cls: "dict-content-text" });
      content.createDiv({ cls: "dict-ai-loading-text", text: "\uB85C\uB529 \uC911..." });
      sections.antonyms = { container: section, content };
    }
    if (displayFields.examples) {
      const section = container.createDiv({ cls: "dict-section" });
      const labelCell = section.createDiv({ cls: "dict-label-cell" });
      labelCell.createSpan({ cls: "dict-label-tag dict-label-example", text: "\uC6A9  \uB840" });
      const content = section.createDiv({ cls: "dict-content-text" });
      content.createDiv({ cls: "dict-ai-loading-text", text: "\uB85C\uB529 \uC911..." });
      sections.examples = { container: section, content };
    }
    if (this.plugin.settings.aiEnabled) {
      const aiResult = await generateAIContent(
        word,
        definition,
        this.plugin.settings.aiProvider,
        this.plugin.settings.aiApiKey,
        this.plugin.settings.aiModel,
        aiGenerateFields
      );
      if (aiResult.error) {
        Object.values(sections).forEach(({ content }) => {
          content.empty();
          content.createDiv({ text: aiResult.error, cls: "dict-ai-error" });
        });
      } else {
        if (sections.hanja) {
          sections.hanja.content.empty();
          if (aiResult.hanja && aiResult.hanja !== "-" && aiResult.hanja.trim() !== "") {
            const hanjaWrapper = sections.hanja.content.createDiv({ cls: "dict-hanja-wrapper" });
            hanjaWrapper.createSpan({ text: aiResult.hanja });
            const copyButton = hanjaWrapper.createEl("button", {
              cls: "dict-copy-button",
              attr: { "aria-label": "\uB178\uD2B8\uC5D0 \uBD99\uC5EC\uB123\uAE30" }
            });
            (0, import_obsidian2.setIcon)(copyButton, "copy");
            copyButton.addEventListener("click", async () => {
              const leaf = this.app.workspace.getMostRecentLeaf();
              const view = leaf == null ? void 0 : leaf.view;
              if (view instanceof import_obsidian2.MarkdownView && view.editor) {
                view.editor.replaceSelection(aiResult.hanja);
                new import_obsidian2.Notice("\uD55C\uC790\uB97C \uB178\uD2B8\uC5D0 \uBD99\uC5EC\uB123\uC5C8\uC2B5\uB2C8\uB2E4");
              } else {
                await navigator.clipboard.writeText(aiResult.hanja);
                new import_obsidian2.Notice("\uD55C\uC790\uB97C \uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uD588\uC2B5\uB2C8\uB2E4");
              }
            });
          } else {
            sections.hanja.content.createSpan({ text: "-" });
          }
        }
        if (sections.synonyms) {
          sections.synonyms.content.empty();
          if (aiResult.synonyms && aiResult.synonyms.length > 0) {
            const list = sections.synonyms.content.createDiv({ cls: "dict-word-list" });
            aiResult.synonyms.forEach((syn) => {
              list.createSpan({ cls: "dict-word-item", text: syn });
            });
          } else {
            sections.synonyms.content.createSpan({ text: "-" });
          }
        }
        if (sections.antonyms) {
          sections.antonyms.content.empty();
          if (aiResult.antonyms && aiResult.antonyms.length > 0) {
            const list = sections.antonyms.content.createDiv({ cls: "dict-word-list" });
            aiResult.antonyms.forEach((ant) => {
              list.createSpan({ cls: "dict-word-item", text: ant });
            });
          } else {
            sections.antonyms.content.createSpan({ text: "-" });
          }
        }
        if (sections.examples) {
          sections.examples.content.empty();
          if (aiResult.examples && aiResult.examples.length > 0) {
            aiResult.examples.forEach((example, i) => {
              const exDiv = sections.examples.content.createDiv({ cls: "dict-example" });
              exDiv.createSpan({ cls: "dict-example-num", text: `${i + 1}.` });
              exDiv.createSpan({ text: example });
            });
          } else {
            sections.examples.content.createSpan({ text: "-" });
          }
        }
      }
    } else {
      Object.values(sections).forEach(({ content }) => {
        content.empty();
        content.createDiv({ text: "AI \uBE44\uD65C\uC131\uD654\uB428", cls: "dict-ai-empty" });
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.filterDropdown) {
      this.filterDropdown.remove();
    }
    if (this.closeDropdownHandler) {
      document.removeEventListener("click", this.closeDropdownHandler);
    }
  }
};
var KoreanDictionarySettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Korean Dictionary Settings" });
    containerEl.createEl("h3", { text: "\uD488\uC0AC/\uC815\uC758" });
    new import_obsidian2.Setting(containerEl).setName("\uD45C\uC900\uAD6D\uC5B4\uB300\uC0AC\uC804 API \uD0A4").setDesc("\uAD6D\uB9BD\uAD6D\uC5B4\uC6D0\uC5D0\uC11C \uBC1C\uAE09\uBC1B\uC740 API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694").addText((text) => {
      text.setPlaceholder("API \uD0A4 \uC785\uB825").setValue(this.plugin.settings.dictionaryApiKey).onChange(async (value) => {
        this.plugin.settings.dictionaryApiKey = value;
        if (value && value.trim().length > 0) {
          this.plugin.settings.dictionaryApiStatus = "none";
          await this.plugin.saveSettings();
          this.display();
          const isValid = await this.plugin.validateDictionaryAPI(value);
          this.plugin.settings.dictionaryApiStatus = isValid ? "success" : "error";
          await this.plugin.saveSettings();
          this.display();
        } else {
          this.plugin.settings.dictionaryApiStatus = "none";
          await this.plugin.saveSettings();
          this.display();
        }
      });
    });
    if (this.plugin.settings.dictionaryApiKey && this.plugin.settings.dictionaryApiKey.trim().length > 0) {
      const statusEl = containerEl.createDiv({ cls: "api-status" });
      if (this.plugin.settings.dictionaryApiStatus === "success") {
        statusEl.createSpan({ cls: "api-status-success", text: "\uC5F0\uACB0 \uC131\uACF5" });
      } else if (this.plugin.settings.dictionaryApiStatus === "error") {
        statusEl.createSpan({ cls: "api-status-error", text: "\uC5F0\uACB0 \uC2E4\uD328" });
      } else {
        statusEl.createSpan({ cls: "api-status", text: "\uAC80\uC99D \uC911..." });
      }
    }
    containerEl.createEl("h3", { text: "\uD55C\uC790/\uC720\uC758\uC5B4/\uBC18\uC758\uC5B4/\uC6A9\uB840" });
    new import_obsidian2.Setting(containerEl).setName("AI \uC81C\uACF5\uC790").setDesc("ChatGPT, Gemini, Groq").addDropdown((dropdown) => {
      dropdown.addOption("chatgpt", "ChatGPT").addOption("gemini", "Gemini").addOption("groq", "Groq").setValue(this.plugin.settings.aiProvider).onChange(async (value) => {
        this.plugin.settings.aiProvider = value;
        this.plugin.settings.aiModel = AI_MODELS[value][0];
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("API \uD0A4").setDesc("\uC120\uD0DD\uD55C AI \uC81C\uACF5\uC790\uC758 API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694").addText((text) => {
      text.setPlaceholder("API \uD0A4 \uC785\uB825").setValue(this.plugin.settings.aiApiKey).onChange(async (value) => {
        this.plugin.settings.aiApiKey = value;
        await this.plugin.saveSettings();
        if (value) {
          const isValid = await this.plugin.validateAIAPI(
            this.plugin.settings.aiProvider,
            value,
            this.plugin.settings.aiModel
          );
          this.plugin.settings.aiApiStatus = isValid ? "success" : "error";
          await this.plugin.saveSettings();
          this.display();
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("\uBAA8\uB378").setDesc("\uC0AC\uC6A9\uD560 \uBAA8\uB378\uC744 \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => {
      const models = AI_MODELS[this.plugin.settings.aiProvider];
      models.forEach((model) => {
        dropdown.addOption(model, model);
      });
      dropdown.setValue(this.plugin.settings.aiModel).onChange(async (value) => {
        this.plugin.settings.aiModel = value;
        await this.plugin.saveSettings();
      });
    });
    if (this.plugin.settings.aiApiKey) {
      const statusEl = containerEl.createDiv({ cls: "api-status" });
      if (this.plugin.settings.aiApiStatus === "success") {
        statusEl.createSpan({ cls: "api-status-success", text: "\uC5F0\uACB0 \uC131\uACF5" });
      } else if (this.plugin.settings.aiApiStatus === "error") {
        statusEl.createSpan({ cls: "api-status-error", text: "\uC5F0\uACB0 \uC2E4\uD328" });
      }
    }
  }
};
